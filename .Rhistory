library(factoextra)
library(FactoMineR)
library(tidyverse)
?prcomp
# ---- 데이터 수집 ----
data("decathlon2")
glimpse(decathlon2)
decathlon2
# 마지막 3개의 데이터는 수치 데이터와 거리가 멀다.
new_data = decathlon2{1:23, 1:10}
# 마지막 3개의 데이터는 수치 데이터와 거리가 멀다.
new_data = decathlon2[1:23, 1:10]
glimpswe(new_data)
glimpse(new_data)
# PCA의 수학적 이해
# get_eigenvalue(res.pca): eigenvalues(고유값)/Variance(분산)
# -- 분산이 가장 큰 방향(또는)이 데이터에서 가장 많은 정도를 담고 있는 방향이다.
# -- 데이터의 분산이 클수록 데이터를 의미있게 분석할 수 있다.
iris_pca_m = PCA(iris[, -5], graph = TRUE)
eig_val = get_eigenvalue(iris_pca_m)
eig_val
iris_pca_m = PCA(new_data, graph = TRUE)
eig_val = get_eigenvalue(iris_pca_m)
eig_val
fviz_eig(iris_pca_m, addlabels = TRUE, ylim = c(0, 80))
fviz_eig(new_data, addlabels = TRUE, ylim = c(0, 80))
# 약 2 dimension이면 충분히 많은 정보를 담고 있다고 생각할 수 있음.
var = get_pca_var(iris_pca_m)
var$contrib
# PCA의 수학적 이해
# get_eigenvalue(res.pca): eigenvalues(고유값)/Variance(분산)
# -- 분산이 가장 큰 방향(또는)이 데이터에서 가장 많은 정도를 담고 있는 방향이다.
# -- 데이터의 분산이 클수록 데이터를 의미있게 분석할 수 있다.
iris_pca_m = PCA(iris[, -5], graph = TRUE)
eig_val = get_eigenvalue(iris_pca_m)
eig_val
fviz_eig(iris_pca_m, addlabels = TRUE, ylim = c(0, 80))
# 약 2 dimension이면 충분히 많은 정보를 담고 있다고 생각할 수 있음.
var = get_pca_var(iris_pca_m)
var$contrib
# 요인 맵의 변수에 대한 표현 품질을 나타냅니다. 이 값은 var.cos2 = var.coord * var.coord 의 제곱 좌표로 계산됩니다.
var$cor
# 주성분에 대한 변수의 기여(백분율)가 포함됩니다. 주어진 주성분에 대한 변수(var)의 기여도는 (백분율) : (var.cos2 * 100) / (성분의 총 cos2)입니다.
var$coord
library(corrplot)
corrplot(var$cos2, is.corr = FALSE)
# Total cos2 of variables on Dim.1 and Dim.2
fviz_cos2(iris_pca_m, choice = "var", axes = 1:2)
# Contributions of variables to PC1 (주성분)
fviz_contrib(iris_pca_m, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2 (주성분)
fviz_pca_var(iris_pca_m, clo.var = "cos2",
gradient.cols = c("#00AFBB", "#E7B800", "FC4E07"),
repel = TRUE)
# Contributions of variables to PC2 (주성분)
fviz_pca_var(iris_pca_m, clo.var = "cos2",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE)
# Contributions of variables to PC2 (주성분)
fviz_pca_var(iris_pca_m, col.var = "cos2",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE)
library(randomForest)
library(caret)
library(gridExtra)
library(grid)
library(ggplot2)
library(corrplot)
library(pROC)
library(formattable)
library(dplyr)
library(readr)
install.packages("formattable", lib="/Library/Frameworks/R.framework/Versions/4.1/Resources/library")
library(formattable)
library(caret)
library(ModelMetrics)
library(dplyr)
library(mlbench)
library(tidyr)
data("pimaIndianDiabetes", package = "mlbench")
data("PimaIndianDiabetes", package = "mlbench")
data("PimaIndiansDiabetes", package = "mlbench")
idx = createDataPartition(PimaIndiansDiabetes$diabetes, 0.7)
train = PimaIndiansDiabetes[idx$Resample1, ]
test + PimaIndiansDiabetes[-idx$Resample1, ]
test = PimaIndiansDiabetes[-idx$Resample1, ]
ctrl = trainControl(method = "csv"
, number = 5
, returnResamp = twoClassSummary
, classProbs = TRUE
, savePredictions = TRUE
, verboseIter = FALSE
)
ctrl = trainControl(method = "cv"
, number = 5
, returnResamp = twoClassSummary
, classProbs = TRUE
, savePredictions = TRUE
, verboseIter = FALSE
)
ctrl = trainControl(method = "cv"
, number = 5
, returnResamp = "none"
, summaryFunction = twoClassSummary
, classProbs = TRUE
, savePredictions = TRUE
, verboseIter = FALSE
)
glimpse(train)
modelLookup("gbm")
probs <- seq(.1, 0.9, by = 0.02)
ths_df <- thresholder(gbm_model
, threshold = probs
, final = TRUE
, statistics = "all")
library(pROC)
library(randomForest)
library(caret)
library(gridExtra)
library(grid)
library(ggplot2)
library(corrplot)
library(pROC)
library(formattable)
library(dplyr)
library(readr)
calculate_roc <- function(verset, cost_of_fp, cost_of_fn, n=100) {
tp <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 1)}
fp <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 0)}
tn <- function(verset, threshold) {sum(verset$predicted <  threshold & verset$Class == 0)}
fn <- function(verset, threshold) {sum(verset$predicted <  threshold & verset$Class == 1)}
tpr <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 1) / sum(verset$Class == 1)}
fpr <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 0) / sum(verset$Class == 0)}
cost <- function(verset, threshold, cost_of_fp, cost_of_fn) { sum(verset$predicted >= threshold & verset$Class == 0) * cost_of_fp +
sum(verset$predicted < threshold & verset$Class == 1) * cost_of_fn}
threshold_round <- function(value, threshold){return (as.integer(!(value < threshold)))}
auc_ <- function(verset, threshold) { auc(verset$Class, threshold_round(verset$predicted,threshold))}
roc <- data.frame(threshold = seq(0,1,length.out=n), tpr=NA, fpr=NA)
roc$tp <- sapply(roc$threshold, function(th) tp(verset, th))
roc$fp <- sapply(roc$threshold, function(th) fp(verset, th))
roc$tn <- sapply(roc$threshold, function(th) tn(verset, th))
roc$fn <- sapply(roc$threshold, function(th) fn(verset, th))
roc$tpr <- sapply(roc$threshold, function(th) tpr(verset, th))
roc$fpr <- sapply(roc$threshold, function(th) fpr(verset, th))
roc$cost <- sapply(roc$threshold, function(th) cost(verset, th, cost_of_fp, cost_of_fn))
roc$auc <-  sapply(roc$threshold, function(th) auc_(verset, th))
return(roc)
}
plot_roc <- function(roc, threshold, cost_of_fp, cost_of_fn) {
library(gridExtra)
norm_vec <- function(v) (v - min(v))/diff(range(v))
idx_threshold = which.min(abs(roc$threshold-threshold))
col_ramp <- colorRampPalette(c("green","orange","red","black"))(100)
col_by_cost <- col_ramp[ceiling(norm_vec(roc$cost)*99)+1]
p_roc <- ggplot(roc, aes(fpr,tpr)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=2, alpha=0.5) +
labs(title = sprintf("ROC")) + xlab("FPR") + ylab("TPR") +
geom_hline(yintercept=roc[idx_threshold,"tpr"], alpha=0.5, linetype="dashed") +
geom_vline(xintercept=roc[idx_threshold,"fpr"], alpha=0.5, linetype="dashed")
p_auc <- ggplot(roc, aes(threshold, auc)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=2, alpha=0.5) +
labs(title = sprintf("AUC")) +
geom_vline(xintercept=threshold, alpha=0.5, linetype="dashed")
p_cost <- ggplot(roc, aes(threshold, cost)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=2, alpha=0.5) +
labs(title = sprintf("cost function")) +
geom_vline(xintercept=threshold, alpha=0.5, linetype="dashed")
sub_title <- sprintf("threshold at %.2f - cost of FP = %d, cost of FN = %d", threshold, cost_of_fp, cost_of_fn)
grid.arrange(p_roc, p_auc, p_cost, ncol=2,sub=textGrob(sub_title, gp=gpar(cex=1), just="bottom"))
}
plot_confusion_matrix <- function(verset, sSubtitle) {
tst <- data.frame(round(verset$predicted,0), verset$Class)
opts <-  c("Predicted", "True")
names(tst) <- opts
cf <- plyr::count(tst)
cf[opts][cf[opts]==0] <- "Not Fraud"
cf[opts][cf[opts]==1] <- "Fraud"
ggplot(data =  cf, mapping = aes(x = True, y = Predicted)) +
labs(title = "Confusion matrix", subtitle = sSubtitle) +
geom_tile(aes(fill = freq), colour = "grey") +
geom_text(aes(label = sprintf("%1.0f", freq)), vjust = 1) +
scale_fill_gradient(low = "lightblue", high = "blue") +
theme_bw() + theme(legend.position = "none")
}
glimpse(train)
modelLookup("gbm")
??gbm
library(randomForest)
library(caret)
library(gridExtra)
library(grid)
library(ggplot2)
library(corrplot)
library(pROC)
library(formattable)
library(dplyr)
library(readr)
# ---- Utils Function ----
calculate_roc <- function(verset, cost_of_fp, cost_of_fn, n=100) {
tp <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 1)}
fp <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 0)}
tn <- function(verset, threshold) {sum(verset$predicted <  threshold & verset$Class == 0)}
fn <- function(verset, threshold) {sum(verset$predicted <  threshold & verset$Class == 1)}
tpr <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 1) / sum(verset$Class == 1)}
fpr <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 0) / sum(verset$Class == 0)}
cost <- function(verset, threshold, cost_of_fp, cost_of_fn) { sum(verset$predicted >= threshold & verset$Class == 0) * cost_of_fp +
sum(verset$predicted < threshold & verset$Class == 1) * cost_of_fn}
threshold_round <- function(value, threshold){return (as.integer(!(value < threshold)))}
auc_ <- function(verset, threshold) { auc(verset$Class, threshold_round(verset$predicted,threshold))}
roc <- data.frame(threshold = seq(0,1,length.out=n), tpr=NA, fpr=NA)
roc$tp <- sapply(roc$threshold, function(th) tp(verset, th))
roc$fp <- sapply(roc$threshold, function(th) fp(verset, th))
roc$tn <- sapply(roc$threshold, function(th) tn(verset, th))
roc$fn <- sapply(roc$threshold, function(th) fn(verset, th))
roc$tpr <- sapply(roc$threshold, function(th) tpr(verset, th))
roc$fpr <- sapply(roc$threshold, function(th) fpr(verset, th))
roc$cost <- sapply(roc$threshold, function(th) cost(verset, th, cost_of_fp, cost_of_fn))
roc$auc <-  sapply(roc$threshold, function(th) auc_(verset, th))
return(roc)
}
# roc plot
plot_roc <- function(roc, threshold, cost_of_fp, cost_of_fn) {
library(gridExtra)
norm_vec <- function(v) (v - min(v))/diff(range(v))
idx_threshold = which.min(abs(roc$threshold-threshold))
col_ramp <- colorRampPalette(c("green","orange","red","black"))(100)
col_by_cost <- col_ramp[ceiling(norm_vec(roc$cost)*99)+1]
p_roc <- ggplot(roc, aes(fpr,tpr)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=2, alpha=0.5) +
labs(title = sprintf("ROC")) + xlab("FPR") + ylab("TPR") +
geom_hline(yintercept=roc[idx_threshold,"tpr"], alpha=0.5, linetype="dashed") +
geom_vline(xintercept=roc[idx_threshold,"fpr"], alpha=0.5, linetype="dashed")
p_auc <- ggplot(roc, aes(threshold, auc)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=2, alpha=0.5) +
labs(title = sprintf("AUC")) +
geom_vline(xintercept=threshold, alpha=0.5, linetype="dashed")
p_cost <- ggplot(roc, aes(threshold, cost)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=2, alpha=0.5) +
labs(title = sprintf("cost function")) +
geom_vline(xintercept=threshold, alpha=0.5, linetype="dashed")
sub_title <- sprintf("threshold at %.2f - cost of FP = %d, cost of FN = %d", threshold, cost_of_fp, cost_of_fn)
grid.arrange(p_roc, p_auc, p_cost, ncol=2,sub=textGrob(sub_title, gp=gpar(cex=1), just="bottom"))
}
# plot confusion matrix
plot_confusion_matrix <- function(verset, sSubtitle) {
tst <- data.frame(round(verset$predicted,0), verset$Class)
opts <-  c("Predicted", "True")
names(tst) <- opts
cf <- plyr::count(tst)
cf[opts][cf[opts]==0] <- "Not Fraud"
cf[opts][cf[opts]==1] <- "Fraud"
ggplot(data =  cf, mapping = aes(x = True, y = Predicted)) +
labs(title = "Confusion matrix", subtitle = sSubtitle) +
geom_tile(aes(fill = freq), colour = "grey") +
geom_text(aes(label = sprintf("%1.0f", freq)), vjust = 1) +
scale_fill_gradient(low = "lightblue", high = "blue") +
theme_bw() + theme(legend.position = "none")
}
# ---- 상관관계 그래프 ----
# ---- 상관관계 그래프 ----
# - 상관관계가 약한 이유는 사전에 이미 PCA로 적합이 이뤄졌기 때문임.
# ---- Feature Importance
# ---- Feature Importance
# 연속 변수 시, MSE & Node Purity
# ---- Feature Importance
# 연속 변수 시, MSE & Node Purity
# 명목 변수 시, mean descrease in accuracy & mean decrease in Gini index
# ---- roc_auc 그래프 ----
# ---- roc_auc 그래프 ----
# ---- 데이터 불러오기 ----
raw.data = read_csv("data/creditcard.csv")
View(raw.data)
table(raw.data$Class)
idx = createDataPartition(raw.data$Class, p = 0.2, list = f)
raw.data = raw.data[idx, ]
table(raw.data$Class)
idx = createDataPartition(raw.data$Class, p = 0.2, list = F)
raw.data = raw.data[idx, ]
table(raw.data$Class)
set.seed(2021)
idx = createDataPartition(raw.data$Class, p = 0.2, list = F)
raw.data = raw.data[idx, ]
table(raw.data$Class)
# ---- 데이터 불러오기 ----
raw.data = read_csv("data/creditcard.csv")
table(raw.data$Class)
idx = createDataPartition(raw.data$Class, p = 0.2, list = F)
raw.data = raw.data[idx, ]
table(raw.data$Class)
set.seed(2021)
idx = createDataPartition(raw.data$Class, p = 0.2, list = F)
raw.data = raw.data[idx, ]
table(raw.data$Class)
head(raw.data$Class)
# ---- 데이터 불러오기 ----
raw.data = read_csv("data/creditcard.csv")
table(raw.data$Class)
#set.seed(2021)
idx = createDataPartition(raw.data$Class, p = 0.2, list = F)
raw.data = raw.data[idx, ]
table(raw.data$Class)
head(raw.data$Class)
glimpse(raw.data$Class)
glimpse(raw.data)
correlation_df = cor(raw.data, method = "pearson")
corrplot(correlation_df, number.cex = .9, method = "circle",
type = "full", tl.cex = 0.8, tl.col = "blach")
# ---- 데이터 분리
set.seed(314)
nrow <- nrow(raw.data)
index =sample(1:nrow(raw.data), 0.7*nrow)
trainset = row.data[index, ]
fr_form = as.formula(paste("Class ~", paste(n[!n %in%])))
# ---- 데이터 분리
set.seed(314)
nrow <- nrow(raw.data)
index =sample(1:nrow(raw.data), 0.7*nrow)
trainset = row.data[index, ]
trainset = raw.data[index, ]
testset = raw.data[-index, ]
table(trainset)
table(testset)
fr_form = as.formula(paste("Class ~", paste(n[!n %in% "Class"], collapse = "+")))
train_rf = randomForest(Clㅁ)
ggplot(variance_imp, aes(x = reorder(rownames(variance_imp), IncNodePurity)
, y = IncNodePurity)) +
geom_bar(stat = "identity", fill ="lightblue") +
coord_flip() +
theme_minimal()
# ---- Utils Function ----
calculate_roc <- function(verset, cost_of_fp, cost_of_fn, n=100) {
tp <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 1)}
fp <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 0)}
tn <- function(verset, threshold) {sum(verset$predicted <  threshold & verset$Class == 0)}
fn <- function(verset, threshold) {sum(verset$predicted <  threshold & verset$Class == 1)}
tpr <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 1) / sum(verset$Class == 1)}
fpr <- function(verset, threshold) {sum(verset$predicted >= threshold & verset$Class == 0) / sum(verset$Class == 0)}
cost <- function(verset, threshold, cost_of_fp, cost_of_fn) { sum(verset$predicted >= threshold & verset$Class == 0) * cost_of_fp +
sum(verset$predicted < threshold & verset$Class == 1) * cost_of_fn}
threshold_round <- function(value, threshold){return (as.integer(!(value < threshold)))}
auc_ <- function(verset, threshold) { auc(verset$Class, threshold_round(verset$predicted,threshold))}
roc <- data.frame(threshold = seq(0,1,length.out=n), tpr=NA, fpr=NA)
roc$tp <- sapply(roc$threshold, function(th) tp(verset, th))
roc$fp <- sapply(roc$threshold, function(th) fp(verset, th))
roc$tn <- sapply(roc$threshold, function(th) tn(verset, th))
roc$fn <- sapply(roc$threshold, function(th) fn(verset, th))
roc$tpr <- sapply(roc$threshold, function(th) tpr(verset, th))
roc$fpr <- sapply(roc$threshold, function(th) fpr(verset, th))
roc$cost <- sapply(roc$threshold, function(th) cost(verset, th, cost_of_fp, cost_of_fn))
roc$auc <-  sapply(roc$threshold, function(th) auc_(verset, th))
return(roc)
}
# roc plot
plot_roc <- function(roc, threshold, cost_of_fp, cost_of_fn) {
library(gridExtra)
norm_vec <- function(v) (v - min(v))/diff(range(v))
idx_threshold = which.min(abs(roc$threshold-threshold))
col_ramp <- colorRampPalette(c("green","orange","red","black"))(100)
col_by_cost <- col_ramp[ceiling(norm_vec(roc$cost)*99)+1]
p_roc <- ggplot(roc, aes(fpr,tpr)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=2, alpha=0.5) +
labs(title = sprintf("ROC")) + xlab("FPR") + ylab("TPR") +
geom_hline(yintercept=roc[idx_threshold,"tpr"], alpha=0.5, linetype="dashed") +
geom_vline(xintercept=roc[idx_threshold,"fpr"], alpha=0.5, linetype="dashed")
p_auc <- ggplot(roc, aes(threshold, auc)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=2, alpha=0.5) +
labs(title = sprintf("AUC")) +
geom_vline(xintercept=threshold, alpha=0.5, linetype="dashed")
p_cost <- ggplot(roc, aes(threshold, cost)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=2, alpha=0.5) +
labs(title = sprintf("cost function")) +
geom_vline(xintercept=threshold, alpha=0.5, linetype="dashed")
sub_title <- sprintf("threshold at %.2f - cost of FP = %d, cost of FN = %d", threshold, cost_of_fp, cost_of_fn)
grid.arrange(p_roc, p_auc, p_cost, ncol=2,sub=textGrob(sub_title, gp=gpar(cex=1), just="bottom"))
}
# plot confusion matrix
plot_confusion_matrix <- function(verset, sSubtitle) {
tst <- data.frame(round(verset$predicted,0), verset$Class)
opts <-  c("Predicted", "True")
names(tst) <- opts
cf <- plyr::count(tst)
cf[opts][cf[opts]==0] <- "Not Fraud"
cf[opts][cf[opts]==1] <- "Fraud"
ggplot(data =  cf, mapping = aes(x = True, y = Predicted)) +
labs(title = "Confusion matrix", subtitle = sSubtitle) +
geom_tile(aes(fill = freq), colour = "grey") +
geom_text(aes(label = sprintf("%1.0f", freq)), vjust = 1) +
scale_fill_gradient(low = "lightblue", high = "blue") +
theme_bw() + theme(legend.position = "none")
}
# ---- 데이터 분리
set.seed(314)
nrow <- nrow(raw.data)
index =sample(1:nrow(raw.data), 0.7*nrow)
trainset = raw.data[index, ]
testset = raw.data[-index, ]
table(trainset)
table(testset)
n = names(trainset)
fr_form = as.formula(paste("Class ~", paste(n[!n %in% "Class"], collapse = "+")))
train_rf = randomForest(rf_from, trainset, ntree = 100, importance = T)
train_rf$importance
install.packages("shinydashboard", lib="/Library/Frameworks/R.framework/Versions/4.1/Resources/library")
